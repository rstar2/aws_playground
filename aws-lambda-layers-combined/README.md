# Usage:

1. Create the 'ffmpeg' layer

```sh
$ mkdir layer-ffmpeg
$ cd layer-ffmpeg
$ curl -O https://johnvansickle.com/ffmpeg/builds/ffmpeg-git-amd64-static.tar.xz
$ tar xf ffmpeg-git-amd64-static.tar.xz
$ rm ffmpeg-git-amd64-static.tar.xz
$ mv ffmpeg-git-*-amd64-static ffmpeg
```

This will create a folder structure of the type
```ascii
c
├── ffmpeg/
```

2. Add the layer to a Lambda function

```yml

# 5 layers can be defined
layers:
  ffmpeg:
    path: layer-ffmpeg

functions:
  gifmaker:
    handler: handler.handle
    layers:
      # Ref name is generated by TitleCasing the layer name 'ffmpeg' (so it becomes 'Ffmpeg')
      # and appending 'LambdaLayer'
      - { Ref: FfmpegLambdaLayer }
```

3. So finally the result will be that in the layer will be available in the ``` /opt ``` folder, the whole "layer-ffmpeg" zipped folder will be extracted in "/opt" and in this case this will result in ```/opt/ffmpeg``` where the 'ffmpeg executable is.

So in code in can be accessed with:
```js
const { spawnSync } = require('child_process');
spawnSync(
        '/opt/ffmpeg/ffmpeg',
        [
            '-version',
        ],
        { stdio: 'inherit' }
    );
```
----------

**Note: Problem with approach is that each ```sls deploy``` creates a new layer version even if we change just the function's code, so better is to separate the AWS Layer and the AWS Lambda in 2 separate CloudFormation stacks. To see it in action check the 'aws-lambda-layers-separate' folder**
